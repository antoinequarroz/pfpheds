<!-- src/views/apps/community/CommunityManagement.vue -->
<template>
  <div class="community-management">
    <!-- Navbar -->
    <Navbar />

    <!-- Section de création de communauté -->
    <CreateNewCommunity
      @communityCreated="handleCommunityCreated"
      @showToast="handleShowToast"
    />

    <!-- Liste des Communautés de l'utilisateur -->
    <CommunitiesList
      :communities="userCommunities"
      @manageCommunity="handleManageCommunity"
      @leaveCommunity="handleLeaveCommunity"
      @showToast="handleShowToast"
    />

    <!-- Liste des Communautés Publiques -->
    <PublicCommunitiesList
      :communities="publicCommunitiesComputed"
      @manageCommunity="handleManageCommunityPublic"
      @joinCommunity="handleJoinCommunityPublic"
      @leaveCommunity="handleLeaveCommunityPublic"
      @showToast="handleShowToast"
    />

    <!-- Toast Notifications -->
    <div class="toast-container">
      <div
        v-for="(toast, index) in toasts"
        :key="index"
        :class="['toast', toast.severity]"
      >
        <strong>{{ toast.summary }}</strong>
        <p>{{ toast.detail }}</p>
        <button @click="removeToast(index)">✖</button>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, computed } from "vue";
import Navbar from '@/components/Utils/Navbar.vue';
import CreateNewCommunity from './CreateNewCommunity.vue';
import CommunitiesList from './CommunitiesList.vue';
import PublicCommunitiesList from './PublicCommunitiesList.vue';


import { db, auth } from "../../../firebase.js";
import { ref as dbRef, get, update } from "firebase/database";

import { useRouter } from "vue-router";

export default {
  name: "CommunityManagement",
  components: {
    Navbar,
    CreateNewCommunity,
    CommunitiesList,
    PublicCommunitiesList,
  },
  setup() {
    const router = useRouter();

    // Références réactives
    const communities = ref([]);
    const publicCommunities = ref([]);
    const toasts = ref([]);
    const localCurrentUser = ref(null);

    // Fonctions pour gérer les toasts
    const addToast = (severity, summary, detail) => {
      const toast = { severity, summary, detail };
      toasts.value.push(toast);
      // Supprimer le toast après 3 secondes
      setTimeout(() => {
        const index = toasts.value.indexOf(toast);
        if (index !== -1) {
          removeToast(index);
        }
      }, 3000);
    };

    const removeToast = (index) => {
      toasts.value.splice(index, 1);
    };

    // Fonction pour récupérer l'utilisateur actuel
    const fetchCurrentUser = () => {
      const user = auth.currentUser;
      if (user) {
        localCurrentUser.value = user;
      } else {
        // Gérer l'utilisateur non authentifié
        addToast('error', 'Erreur', 'Utilisateur non authentifié.');
      }
    };

    // Fonction pour récupérer les communautés
    const fetchCommunities = async () => {
      if (!localCurrentUser.value) return;

      try {
        const communitiesSnapshot = await get(dbRef(db, "Communities"));
        if (communitiesSnapshot.exists()) {
          const data = communitiesSnapshot.val();
          const allCommunities = Object.entries(data).map(([key, community]) => ({
            id: key,
            ...community,
            isMember: community.members && community.members[localCurrentUser.value.uid] ? true : false
          }));

          // Filtrer les communautés de l'utilisateur
          const userComms = allCommunities.filter(community => community.isMember);
          // Filtrer les communautés publiques que l'utilisateur n'a pas encore rejoint
          const publicComms = allCommunities.filter(community =>
            community.type === 'public' && !community.isMember
          );

          communities.value = userComms;
          publicCommunities.value = publicComms;
        } else {
          communities.value = [];
          publicCommunities.value = [];
        }
      } catch (error) {
        console.error("Erreur lors de la récupération des communautés :", error);
        addToast('error', 'Erreur', 'Impossible de récupérer les communautés.');
      }
    };

    // Fonction pour gérer une communauté (naviguer vers ManageOneCommunity.vue)
    const handleManageCommunity = (communityId) => {
      router.push({ name: 'ManageOneCommunity', params: { id: communityId } });
    };

    // Fonction pour gérer une communauté publique (si un comportement spécifique est nécessaire)
    const handleManageCommunityPublic = (communityId) => {
      router.push({ name: 'ManageOneCommunity', params: { id: communityId } });
    };

    onMounted(() => {
      fetchCurrentUser();
      fetchCommunities();
    });

    // Fonction appelée lorsque une nouvelle communauté est créée
    const handleCommunityCreated = () => {
      fetchCommunities(); // Rafraîchir la liste des communautés
      addToast('success', 'Succès', 'Nouvelle communauté ajoutée.');
    };

    // Fonction pour gérer les toasts émis par les composants enfants
    const handleShowToast = (toast) => {
      addToast(toast.severity, toast.summary, toast.detail);
    };

    // Fonction pour rejoindre une communauté
    const handleJoinCommunity = async (communityId) => {
      if (!localCurrentUser.value) {
        addToast('error', 'Erreur', 'Utilisateur non authentifié.');
        return;
      }
      const userId = localCurrentUser.value.userid;

      try {
        // Mettre à jour les deux tables de manière atomique
        await update(dbRef(db), {
          [`Communities/${communityId}/members/${userId}`]: true,
          [`Users/${userId}/communities/${communityId}`]: true
        });

        addToast('success', 'Succès', 'Vous avez rejoint la communauté.');
        fetchCommunities();
      } catch (error) {
        console.error("Erreur lors de la jonction de la communauté :", error);
        addToast('error', 'Erreur', 'Impossible de rejoindre la communauté.');
      }
    };

    // Fonction pour quitter une communauté
    const handleLeaveCommunity = async (communityId) => {
      if (!localCurrentUser.value) {
        addToast('error', 'Erreur', 'Utilisateur non authentifié.');
        return;
      }
      const userId = localCurrentUser.value.uid;

      try {
        // Supprimer les deux entrées de manière atomique
        await update(dbRef(db), {
          [`Communities/${communityId}/members/${userId}`]: null,
          [`Users/${userId}/communities/${communityId}`]: null
        });

        addToast('success', 'Succès', 'Vous avez quitté la communauté.');
        fetchCommunities();
      } catch (error) {
        console.error("Erreur lors de la sortie de la communauté :", error);
        addToast('error', 'Erreur', 'Impossible de quitter la communauté.');
      }
    };

    // Fonction pour voir les informations d'une communauté
    const handleViewInfo = (communityId) => {
      router.push({ name: 'CommunityInfo', params: { id: communityId } });
    };

    // Fonctions spécifiques pour les communautés publiques
    const handleJoinCommunityPublic = async (communityId) => {
      await handleJoinCommunity(communityId);
    };

    const handleLeaveCommunityPublic = async (communityId) => {
      await handleLeaveCommunity(communityId);
    };

    const handleViewInfoPublic = (communityId) => {
      handleViewInfo(communityId);
    };

    // Computed property pour les communautés de l'utilisateur
    const userCommunities = computed(() => {
      return communities.value.filter(community => community.isMember);
    });

    // Computed property pour les communautés publiques non rejointes
    const publicCommunitiesComputed = computed(() => {
      return publicCommunities.value;
    });

    return {
      communities,
      publicCommunities,
      userCommunities,
      publicCommunitiesComputed,
      fetchCommunities,
      handleManageCommunity,
      handleManageCommunityPublic,
      handleCommunityCreated,
      handleShowToast,
      handleJoinCommunity,
      handleLeaveCommunity,
      handleViewInfo,
      handleJoinCommunityPublic,
      handleLeaveCommunityPublic,
      handleViewInfoPublic,
      toasts,
      removeToast,
      addToast,
      localCurrentUser
    };
  }
};
</script>

<style scoped>
.community-management {
  padding: 2rem;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: #333333; /* Texte sombre pour un bon contraste */
}


/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 2000;
}

.toast {
  background-color: #333333;
  color: #ffffff;
  padding: 1rem;
  margin-bottom: 0.75rem;
  border-radius: 6px;
  min-width: 250px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.toast.success {
  background-color: #28a745;
}

.toast.error {
  background-color: #dc3545;
}

.toast.warn {
  background-color: #ffc107;
  color: #212529;
}

.toast p {
  margin: 0;
  padding-left: 0.5rem;
}

.toast button {
  background: none;
  border: none;
  color: inherit;
  font-size: 1rem;
  cursor: pointer;
}

/* Responsive Design */
@media (max-width: 768px) {
  .community-management {
    padding: 1rem;
  }


  .toast {
    min-width: 200px;
    padding: 0.75rem;
  }
}
</style>
